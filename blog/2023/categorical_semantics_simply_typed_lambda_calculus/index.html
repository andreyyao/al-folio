<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Categorical Semantics of Simply Typed Lambda Calculus | Andrey W. Yao</title> <meta name="author" content="Andrey W. Yao"> <meta name="description" content="Blank"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://andreyyao.github.io/blog/2023/categorical_semantics_simply_typed_lambda_calculus/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Andrey </span>W. Yao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Categorical Semantics of Simply Typed Lambda Calculus</h1> <p class="post-meta">October 13, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/category"> <i class="fas fa-hashtag fa-sm"></i> category</a>   <a href="/blog/tag/pl"> <i class="fas fa-hashtag fa-sm"></i> pl</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"> <a href="#introduction">Introduction</a> <ul> <li class="toc-entry toc-h2"><a href="#computational-trilogy">Computational trilogy</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#categorical-semantics">Categorical semantics</a> <ul> <li class="toc-entry toc-h2"><a href="#the-type-theory">The type theory</a></li> <li class="toc-entry toc-h2"><a href="#a-cartesian-closed-category">A Cartesian-closed category</a></li> <li class="toc-entry toc-h2"><a href="#the-translation">The translation</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#semantics-respects-equivalence">Semantics respects equivalence</a> <ul> <li class="toc-entry toc-h2"><a href="#eta-equivalence">Eta-equivalence</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a></li> </ul> </div> <hr> <div id="markdown-content"> <h1 id="introduction">Introduction</h1> <p>Computer programs are complicated. How do we develop a better understanding of how they work? <em>Denotational semantics</em> is the subarea of programming languages where people study the behaviors of programs by mapping them into some <em>semantic domain</em> of mathematical objects.</p> <p>The <a href="https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec02.pdf" rel="external nofollow noopener" target="_blank"><em>lambda calculus</em></a> is one of the simplest programming languages there is. Written in Backus-Naur form (BNF), it only has three kinds of expressions:</p> \[e\;:=\;x\;|\;\lambda x.e\;|\;e_1\;e_2\] <p>which stands for variable, function abstraction, and function application. Despite its simplicity, the lambda calculus is Turing-complete, and in particular can represent infinite loops. There has been interesting work in giving semantics to the lambda calculus via <em>domain theory</em>, but that’s the topic for another day.</p> <h2 id="computational-trilogy">Computational trilogy</h2> <p>We will focus our attention on <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus" rel="external nofollow noopener" target="_blank">simply typed lambda calculus</a>(STLC). STLC adds types to the (pure) lambda calculus. As a programming language, STLC is <em>strongly normalizing</em>, meaning that every well-typed term will eventually evaluate to a normal form. That shouldn’t be discouraging, since STLC is closely connected to intuitionistic logic, via the <em>Curry-Howard correspondence</em>. It turns out that logic and type systems are both connected to <em>category theory</em> via the so-called <em>Curry-Howard-Lambek</em> correspondence.</p> <p>The goal of this post is to explicitly spell out a categorical semantics of STLC. I was unable to find proofs for the following table taken from this <a href="https://ncatlab.org/nlab/show/computational+trilogy" rel="external nofollow noopener" target="_blank">nlab page</a> on “computational trilogy”, so I wish to write it down in this blog post.</p> <table> <thead> <tr> <th style="text-align: center">logic</th> <th style="text-align: center">type theory</th> <th style="text-align: center">category theory</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">propositions</td> <td style="text-align: center">types</td> <td style="text-align: center">objects</td> </tr> <tr> <td style="text-align: center">proofs</td> <td style="text-align: center">terms</td> <td style="text-align: center">/</td> </tr> <tr> <td style="text-align: center">impl-intro</td> <td style="text-align: center">\(\lambda\) abstraction</td> <td style="text-align: center">counit from tensor-hom adjunction</td> </tr> <tr> <td style="text-align: center">impl-elim</td> <td style="text-align: center">application</td> <td style="text-align: center">unit from tensor-hom adjunction</td> </tr> <tr> <td style="text-align: center">cut elimination</td> <td style="text-align: center">\(\beta\) reduction</td> <td style="text-align: center">zigzag identities</td> </tr> <tr> <td style="text-align: center">identity elimination</td> <td style="text-align: center">\(\eta\) conversion</td> <td style="text-align: center">other zigzag</td> </tr> </tbody> </table> <p><br></p> <h1 id="categorical-semantics">Categorical semantics</h1> <p>Some of the following definitions are adapted from Benjamin Pierce’s <em>Basic Category for Computer Scientists</em>.</p> <h2 id="the-type-theory">The type theory</h2> <p>We define the grammar for types in STLC:</p> \[\tau\;:=\;\texttt{Unit}\;|\;\tau_1\to\tau_2\;|\;\tau_1\;\times\;\tau_2\] <p>And the grammar for terms:</p> \[e\;:=\;\texttt{unit}\;|\;\lambda x:\tau.e\;|\;e_1\;e_2\;|\;(e_1,e_2)\;|\;\texttt{fst}\;e\;|\;\texttt{snd}\;e\] <p>Here, \(\texttt{Unit}\) is the type with one element \(\texttt{unit}\). we also consider the following typing rules:</p> \[\begin{prooftree} \AXC{ } \RightLabel{Unit} \UIC{$\Gamma\vdash\texttt{unit}:\texttt{Unit}$} \end{prooftree}\] \[\begin{prooftree} \AXC{ } \RightLabel{Var} \UIC{$\Gamma,x:A\vdash x:A$} \end{prooftree} \quad \begin{prooftree} \AXC{$\Gamma\vdash e:A$} \RightLabel{Weaken} \UIC{$\Gamma,y:B\vdash e:A$} \end{prooftree}\] \[\begin{prooftree} \AXC{$\Gamma, x:A\vdash e:B$} \RightLabel{Abs} \UIC{$\Gamma\vdash\lambda x:A. e:A\to B$} \end{prooftree} \quad \begin{prooftree} \AXC{$\Gamma\vdash f:A\to B$} \AXC{$\Gamma\vdash e:A$} \RightLabel{App} \BIC{$\Gamma\vdash f\;e:B$} \end{prooftree}\] \[\begin{prooftree} \AXC{$\Gamma\vdash e:A\times B$} \RightLabel{fst} \UIC{$\Gamma\vdash \texttt{fst}\;e:A$} \end{prooftree} \quad \begin{prooftree} \AXC{$\Gamma\vdash e:A\times B$} \RightLabel{snd} \UIC{$\Gamma\vdash \texttt{snd}\;e:B$} \end{prooftree}\] \[\begin{prooftree} \AXC{$\Gamma\vdash e_1:A$} \AXC{$\Gamma\vdash e_2:B$} \RightLabel{pair} \BIC{$\Gamma\vdash (e_1,e_2):A\times B$} \end{prooftree}\] <h2 id="a-cartesian-closed-category">A Cartesian-closed category</h2> <p>For the other piece of the translation, we fix any Cartesian-closed category (CCC) \(\mathbf{C}\). Recall that a Cartesian-closed category is a category with finite products, such that for each object \(A\), the <em>right product functor</em> \((-\times A):\mathbf{C}\to\mathbf{C}\) has a right adjoint \((-^A):\mathbf{C}\to\mathbf{C}\) called the <em>exponential</em>.</p> <p>The definition of adjunctions come with a unit natural transformation \(\epsilon_A:(-^A\times A)\to \text{Id}_\mathbf{C}\) and a counit natural transformation \(\eta_A:\text{Id}_\mathbf{C}\to (-\times A)^A\) such that the following “zigzag” equalities hold:</p> \[\begin{equation}\mathcal{Id}_{(-\times A)}=\epsilon_A (-\times A)\circ (-\times A)\eta_A\end{equation}\] \[\begin{equation}\mathcal{Id}_{(-^A)}=(-^A)\epsilon_A\circ \eta_A (-^A)\end{equation}\] <p>Here \(\text{Id}_\mathbf{C}\) is the identity functor on \(\mathbf{C}\), and the caligraphic \(\mathcal{Id}\) denotes identity natural transformations on the respective functors.</p> <p>For each object \(B\in\mathbf{C}\), the component \(\epsilon_{A,B}\) of the unit \(\epsilon_A\) has the universal property such that, for any \(C\in\mathbf{C}\) and morphism \(f\) from \((\underline{C}\times A)\) (the product functor applied to \(C\)) to \(B\), there exists a unique morphism \(curry(f)\) from \(C\) to \(B^A\) (the exponential functor applied to \(B\)) making the diagram commute:</p> <div align="center"> <iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXHVuZGVybGluZXtDfVxcdGltZXMgQSJdLFswLDIsIkJeQVxcdGltZXMgQSJdLFsyLDIsIkIiXSxbMSwyLCJcXGVwc2lsb25fe0EsQn0iLDJdLFswLDEsIlxcZXhpc3RzIVxcO2N1cnJ5KGYpXFx0aW1lcyBcXHRleHR7aWR9X0EiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwyLCJmIl1d&amp;embed" width="420" height="400" style="border-radius: 8px; border: none;"></iframe> </div> <p>Dually, for each object \(C\in\mathbf{C}\), the component \(\eta_{A,C}\) of the counit has the universal property that for any \(B\in\mathbf{C}\) and morphism \(g\) from \(C\) to \(\underline{B}^A\), there exists a unique morphism \(uncurry(g)\) such that \((uncurry(g))^A\circ\eta_{A,C}=g\)</p> <h2 id="the-translation">The translation</h2> <p>We are finally ready to define the semantic translation! The double brackets \([\![\;]\!]\) takes something from the type theory and maps it into the CCC we specified. On types, it is defined inductive on the syntax and maps each type to an object in the CCC. Again, the following translations are taken from Pierce’s <em>Basic Category for Computer Scientists</em>:</p> \[\begin{align*} [\![\texttt{Unit}]\!]&amp;\triangleq 1_\mathbf{C}\\ [\![A\times B]\!]&amp;\triangleq [\![A]\!] \times [\![B]\!]\\ [\![A\to B]\!]&amp;\triangleq [\![B]\!]^{[\![A]\!]} \end{align*}\] <p>The translation for the typing context is inductively defined on the number of variables: \([\![\varnothing]\!]\triangleq 1_\mathbf{C}\) and \([\![\Gamma,x:A]\!]\triangleq [\![\Gamma]\!]\times [\![A]\!]\).</p> <p>Finally, we inductively define the translation on the typing derivations:</p> <table> <thead> <tr> <th>Derivation</th> <th>Translation</th> <th>Domain</th> <th>Target</th> </tr> </thead> <tbody> <tr> <td>\([\![\Gamma\vdash \texttt{unit}:\texttt{Unit}]\!]\)</td> <td>\(!_{[\![\Gamma]\!]}\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\(1_\mathbf{C}\)</td> </tr> <tr> <td>\([\![\Gamma,x:A\vdash x:A]\!]\)</td> <td>\(\pi_2\)</td> <td>\([\![\Gamma]\!]\times[\![A]\!]\)</td> <td>\([\![A]\!]\)</td> </tr> <tr> <td>\([\![\Gamma,y:B\vdash e:A]\!]\)</td> <td>\([\![\Gamma\vdash e:A]\!]\circ\pi_1\)</td> <td>\([\![\Gamma]\!]\times[\![A]\!]\)</td> <td>\([\![B]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash \lambda x:A.e:A\to B]\!]\)</td> <td>\(curry([\![\Gamma,x:A\vdash e:B]\!])\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![B]\!]^{[\![A]\!]}\)</td> </tr> <tr> <td>\([\![\Gamma\vdash e_1\;e_2:B]\!]\)</td> <td>\(\epsilon_{A,B}\circ\langle[\![\Gamma\vdash e_1:A\to B]\!],[\![\Gamma\vdash e_2:A]\!]\rangle\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![B]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash (e_1,e_2):A\times B]\!]\)</td> <td>\(\langle[\![\Gamma\vdash e_1:A]\!],[\![\Gamma\vdash e_2:B]\!]\rangle\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![A]\!]\times[\![B]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash \texttt{fst}\;e:A]\!]\)</td> <td>\(\pi_1\circ [\![\Gamma\vdash (e_1,e_2):A\times B]\!]\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![A]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash \texttt{snd}\;e:B]\!]\)</td> <td>\(\pi_2\circ [\![\Gamma\vdash (e_1,e_2):A\times B]\!]\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![B]\!]\)</td> </tr> </tbody> </table> <p><br></p> <p>For this particular formulation of STLC, it just so happens that for any fixed context, if a term is typeable then there is a unique typing rule that applies to it. This can be seen just from the fact that each term grammar branch appears in the conclusion of exactly one typing rule. Thus, we can be a little hand-wavy and define the translations on the term syntax directly.</p> <h1 id="semantics-respects-equivalence">Semantics respects equivalence</h1> <h2 id="eta-equivalence">Eta-equivalence</h2> <p>The \(\eta\)-equivalence says that for whatever types \(A,B\), a function \(h:A\to B\) should be considered “the same” as \(\lambda x:A. h\;x\). Indeed, the latter seems to be just “\(h\) with extra steps”. It turns out our categorical interpretation respects this equivalence.</p> <p>Now for the proof. Suppose \(\Gamma\vdash \lambda x:A.e\;x:A\to B\). Then \(e\) must be of type \(A\to B\), but it doesn’t have to be in normal form. Here we “cheat” a bit and assume that we never reuse variable names. That is, \(x\) should not be a free variable in \(e\). This is a reasonable assumption though. The semantics of the typing derivations defined earlier tells us</p> \[\begin{align*} &amp;[\![\Gamma\vdash \lambda x:A.e\;x:A\to B]\!]\\ =&amp;curry([\![\Gamma,x:A \vdash e\;x:B]\!])\\ =&amp;curry(\epsilon_{A,B}\circ \langle[\![\Gamma,x:A\vdash e:A\to B]\!],[\![\Gamma,x:A\vdash x:A]\!]\rangle)\\ =&amp;curry(\epsilon_{A,B}\circ \langle[\![\Gamma,x:A\vdash e:A\to B]\!],\pi_2\rangle)\\ =&amp;curry(\epsilon_{A,B}\circ \langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle) \end{align*}\] <p>Tho a mouthful, \(\epsilon_{A,B}\circ\langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle\) is a morphism from \([\![\Gamma]\!]\times [\![A]\!]\) to \([\![B]\!]\). If we set \(C\) to be \([\![\Gamma]\!]\), and \(f\) as \(\epsilon_{A,B}\circ\langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle\), then the diagram for the unit equation becomes</p> <div align="center"> <iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsMyxbMCwwLCJbXFwhW1xcR2FtbWFdXFwhXVxcdGltZXMgW1xcIVtBXVxcIV0iXSxbMCwyLCJbXFwhW0JdXFwhXV57W1xcIVtBXVxcIV19XFx0aW1lcyBbXFwhW0FdXFwhXSJdLFsyLDIsIltcXCFbQl1cXCFdIl0sWzEsMiwiXFxlcHNpbG9uX3tBLEJ9IiwyXSxbMCwxLCJnIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMiwiZiJdXQ==&amp;embed" width="400" height="400" style="border-radius: 8px; border: none;"></iframe> </div> <p>Where did the mystery \(g\) come from? Well, since \(f\) is of the form \(\epsilon_{A,B}\) composed with <em>something</em>, we can just define \(g\) to be the <em>something</em>, aka \(\langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle\), and the above diagram will trivially commute. But, note \(g\) actually equal to \([\![\Gamma\vdash e:A\to B]\!]\times \text{id}_{[\![A]\!]}\).</p> <p>Finally, for the real kicker, we invoke the uniqueness of \(curry\) in the universal property of \(\epsilon_A\), so that \([\![\Gamma\vdash e:A\to B]\!]=curry(\epsilon_{A,B}\circ \langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle)\). This concludes the proof that our categorical semantics respects eta-equivalence:</p> \[[\![\Gamma\vdash \lambda x:A.e\;x:A\to B]\!]=[\![\Gamma\vdash e:A\to B]\!]\] <h1 id="conclusion">Conclusion</h1> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Andrey W. Yao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: October 16, 2023. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>