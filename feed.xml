<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://andreyyao.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://andreyyao.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-10-16T19:30:34+00:00</updated><id>https://andreyyao.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Categorical Semantics of Simply Typed Lambda Calculus</title><link href="https://andreyyao.github.io/blog/2023/categorical_semantics_simply_typed_lambda_calculus/" rel="alternate" type="text/html" title="Categorical Semantics of Simply Typed Lambda Calculus"/><published>2023-10-13T15:12:00+00:00</published><updated>2023-10-13T15:12:00+00:00</updated><id>https://andreyyao.github.io/blog/2023/categorical_semantics_simply_typed_lambda_calculus</id><content type="html" xml:base="https://andreyyao.github.io/blog/2023/categorical_semantics_simply_typed_lambda_calculus/"><![CDATA[<h1 id="introduction">Introduction</h1> <p>Computer programs are complicated. How do we develop a better understanding of how they work? <em>Denotational semantics</em> is the subarea of programming languages where people study the behaviors of programs by mapping them into some <em>semantic domain</em> of mathematical objects.</p> <p>The <a href="https://www.cs.cornell.edu/courses/cs6110/2023sp/lectures/lec02.pdf"><em>lambda calculus</em></a> is one of the simplest programming languages there is. Written in Backus-Naur form (BNF), it only has three kinds of expressions:</p> \[e\;:=\;x\;|\;\lambda x.e\;|\;e_1\;e_2\] <p>which stands for variable, function abstraction, and function application. Despite its simplicity, the lambda calculus is Turing-complete, and in particular can represent infinite loops. There has been interesting work in giving semantics to the lambda calculus via <em>domain theory</em>, but that’s the topic for another day.</p> <h2 id="computational-trilogy">Computational trilogy</h2> <p>We will focus our attention on <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus</a>(STLC). STLC adds types to the (pure) lambda calculus. As a programming language, STLC is <em>strongly normalizing</em>, meaning that every well-typed term will eventually evaluate to a normal form. That shouldn’t be discouraging, since STLC is closely connected to intuitionistic logic, via the <em>Curry-Howard correspondence</em>. It turns out that logic and type systems are both connected to <em>category theory</em> via the so-called <em>Curry-Howard-Lambek</em> correspondence.</p> <p>The goal of this post is to explicitly spell out a categorical semantics of STLC. I was unable to find proofs for the following table taken from this <a href="https://ncatlab.org/nlab/show/computational+trilogy">nlab page</a> on “computational trilogy”, so I wish to write it down in this blog post.</p> <table> <thead> <tr> <th style="text-align: center">logic</th> <th style="text-align: center">type theory</th> <th style="text-align: center">category theory</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">propositions</td> <td style="text-align: center">types</td> <td style="text-align: center">objects</td> </tr> <tr> <td style="text-align: center">proofs</td> <td style="text-align: center">terms</td> <td style="text-align: center">/</td> </tr> <tr> <td style="text-align: center">impl-intro</td> <td style="text-align: center">\(\lambda\) abstraction</td> <td style="text-align: center">counit from tensor-hom adjunction</td> </tr> <tr> <td style="text-align: center">impl-elim</td> <td style="text-align: center">application</td> <td style="text-align: center">unit from tensor-hom adjunction</td> </tr> <tr> <td style="text-align: center">cut elimination</td> <td style="text-align: center">\(\beta\) reduction</td> <td style="text-align: center">zigzag identities</td> </tr> <tr> <td style="text-align: center">identity elimination</td> <td style="text-align: center">\(\eta\) conversion</td> <td style="text-align: center">other zigzag</td> </tr> </tbody> </table> <p><br/></p> <h1 id="categorical-semantics">Categorical semantics</h1> <p>Some of the following definitions are adapted from Benjamin Pierce’s <em>Basic Category for Computer Scientists</em>.</p> <h2 id="the-type-theory">The type theory</h2> <p>We define the grammar for types in STLC:</p> \[\tau\;:=\;\texttt{Unit}\;|\;\tau_1\to\tau_2\;|\;\tau_1\;\times\;\tau_2\] <p>And the grammar for terms:</p> \[e\;:=\;\texttt{unit}\;|\;\lambda x:\tau.e\;|\;e_1\;e_2\;|\;(e_1,e_2)\;|\;\texttt{fst}\;e\;|\;\texttt{snd}\;e\] <p>Here, \(\texttt{Unit}\) is the type with one element \(\texttt{unit}\). we also consider the following typing rules:</p> \[\begin{prooftree} \AXC{ } \RightLabel{Unit} \UIC{$\Gamma\vdash\texttt{unit}:\texttt{Unit}$} \end{prooftree}\] \[\begin{prooftree} \AXC{ } \RightLabel{Var} \UIC{$\Gamma,x:A\vdash x:A$} \end{prooftree} \quad \begin{prooftree} \AXC{$\Gamma\vdash e:A$} \RightLabel{Weaken} \UIC{$\Gamma,y:B\vdash e:A$} \end{prooftree}\] \[\begin{prooftree} \AXC{$\Gamma, x:A\vdash e:B$} \RightLabel{Abs} \UIC{$\Gamma\vdash\lambda x:A. e:A\to B$} \end{prooftree} \quad \begin{prooftree} \AXC{$\Gamma\vdash f:A\to B$} \AXC{$\Gamma\vdash e:A$} \RightLabel{App} \BIC{$\Gamma\vdash f\;e:B$} \end{prooftree}\] \[\begin{prooftree} \AXC{$\Gamma\vdash e:A\times B$} \RightLabel{fst} \UIC{$\Gamma\vdash \texttt{fst}\;e:A$} \end{prooftree} \quad \begin{prooftree} \AXC{$\Gamma\vdash e:A\times B$} \RightLabel{snd} \UIC{$\Gamma\vdash \texttt{snd}\;e:B$} \end{prooftree}\] \[\begin{prooftree} \AXC{$\Gamma\vdash e_1:A$} \AXC{$\Gamma\vdash e_2:B$} \RightLabel{pair} \BIC{$\Gamma\vdash (e_1,e_2):A\times B$} \end{prooftree}\] <h2 id="a-cartesian-closed-category">A Cartesian-closed category</h2> <p>For the other piece of the translation, we fix any Cartesian-closed category (CCC) \(\mathbf{C}\). Recall that a Cartesian-closed category is a category with finite products, such that for each object \(A\), the <em>right product functor</em> \((-\times A):\mathbf{C}\to\mathbf{C}\) has a right adjoint \((-^A):\mathbf{C}\to\mathbf{C}\) called the <em>exponential</em>.</p> <p>The definition of adjunctions come with a unit natural transformation \(\epsilon_A:(-^A\times A)\to \text{Id}_\mathbf{C}\) and a counit natural transformation \(\eta_A:\text{Id}_\mathbf{C}\to (-\times A)^A\) such that the following “zigzag” equalities hold:</p> \[\begin{equation}\mathcal{Id}_{(-\times A)}=\epsilon_A (-\times A)\circ (-\times A)\eta_A\label{eq:unit}\end{equation}\] \[\begin{equation}\mathcal{Id}_{(-^A)}=(-^A)\epsilon_A\circ \eta_A (-^A)\label{eq:counit}\end{equation}\] <p>Here \(\text{Id}_\mathbf{C}\) is the identity functor on \(\mathbf{C}\), and the caligraphic \(\mathcal{Id}\) denotes identity natural transformations on the respective functors.</p> <p>An alternative formulation of \eqref{eq:unit} is useful as follows. For each object \(B\in\mathbf{C}\), the component \(\epsilon_{A,B}\) of the unit \(\epsilon_A\) has the universal property such that, for any \(C\in\mathbf{C}\) and morphism \(f\) from \((\underline{C}\times A)\) (the product functor applied to \(C\)) to \(B\), there exists a unique morphism \(curry(f)\) from \(C\) to \(B^A\) (the exponential functor applied to \(B\)) making the diagram commute:</p> <div align="center"> <iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXHVuZGVybGluZXtDfVxcdGltZXMgQSJdLFswLDIsIkJeQVxcdGltZXMgQSJdLFsyLDIsIkIiXSxbMSwyLCJcXGVwc2lsb25fe0EsQn0iLDJdLFswLDEsIlxcZXhpc3RzIVxcO2N1cnJ5KGYpXFx0aW1lcyBcXHRleHR7aWR9X0EiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwyLCJmIl1d&amp;embed" width="420" height="400" style="border-radius: 8px; border: none;"></iframe> </div> <h2 id="the-translation">The translation</h2> <p>We are finally ready to define the semantic translation! The double brackets \([\![\;]\!]\) takes something from the type theory and maps it into the CCC we specified. On types, it is defined inductive on the syntax and maps each type to an object in the CCC. Again, the following translations are taken from Pierce’s <em>Basic Category for Computer Scientists</em>:</p> \[\begin{align*} [\![\texttt{Unit}]\!]&amp;\triangleq 1_\mathbf{C}\\ [\![A\times B]\!]&amp;\triangleq [\![A]\!] \times [\![B]\!]\\ [\![A\to B]\!]&amp;\triangleq [\![B]\!]^{[\![A]\!]} \end{align*}\] <p>The translation for the typing context is inductively defined on the number of variables: \([\![\varnothing]\!]\triangleq 1_\mathbf{C}\) and \([\![\Gamma,x:A]\!]\triangleq [\![\Gamma]\!]\times [\![A]\!]\).</p> <p>Finally, we inductively define the translation on the typing derivations:</p> <table> <thead> <tr> <th>Derivation</th> <th>Translation</th> <th>Domain</th> <th>Target</th> </tr> </thead> <tbody> <tr> <td>\([\![\Gamma\vdash \texttt{unit}:\texttt{Unit}]\!]\)</td> <td>\(!_{[\![\Gamma]\!]}\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\(1_\mathbf{C}\)</td> </tr> <tr> <td>\([\![\Gamma,x:A\vdash x:A]\!]\)</td> <td>\(\pi_2\)</td> <td>\([\![\Gamma]\!]\times[\![A]\!]\)</td> <td>\([\![A]\!]\)</td> </tr> <tr> <td>\([\![\Gamma,y:B\vdash e:A]\!]\)</td> <td>\([\![\Gamma\vdash e:A]\!]\circ\pi_1\)</td> <td>\([\![\Gamma]\!]\times[\![A]\!]\)</td> <td>\([\![B]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash \lambda x:A.e:A\to B]\!]\)</td> <td>\(curry([\![\Gamma,x:A\vdash e:B]\!])\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![B]\!]^{[\![A]\!]}\)</td> </tr> <tr> <td>\([\![\Gamma\vdash e_1\;e_2:B]\!]\)</td> <td>\(\epsilon_{A,B}\circ\langle[\![\Gamma\vdash e_1:A\to B]\!],[\![\Gamma\vdash e_2:A]\!]\rangle\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![B]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash (e_1,e_2):A\times B]\!]\)</td> <td>\(\langle[\![\Gamma\vdash e_1:A]\!],[\![\Gamma\vdash e_2:B]\!]\rangle\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![A]\!]\times[\![B]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash \texttt{fst}\;e:A]\!]\)</td> <td>\(\pi_1\circ [\![\Gamma\vdash (e_1,e_2):A\times B]\!]\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![A]\!]\)</td> </tr> <tr> <td>\([\![\Gamma\vdash \texttt{snd}\;e:B]\!]\)</td> <td>\(\pi_2\circ [\![\Gamma\vdash (e_1,e_2):A\times B]\!]\)</td> <td>\([\![\Gamma]\!]\)</td> <td>\([\![B]\!]\)</td> </tr> </tbody> </table> <p><br/></p> <p>For this particular formulation of STLC, it just so happens that for any fixed context, if a term is typeable then there is a unique typing rule that applies to it. This can be seen just from the fact that each term grammar branch appears in the conclusion of exactly one typing rule. Thus, we can be a little hand-wavy and define the translations on the term syntax directly.</p> <h1 id="semantics-respects-equivalence">Semantics respects equivalence</h1> <h2 id="eta-equivalence">Eta-equivalence</h2> <p>The \(\eta\)-equivalence says that for whatever types \(A,B\), a function \(h:A\to B\) should be considered “the same” as \(\lambda x:A. h\;x\). Indeed, the latter seems to be just “\(h\) with extra steps”. It turns out our categorical interpretation respects this equivalence.</p> <p>Now for the proof. Suppose \(\Gamma\vdash \lambda x:A.e\;x:A\to B\). Then \(e\) must be of type \(A\to B\), but it doesn’t have to be in normal form. Here we “cheat” a bit and assume that we never reuse variable names. That is, \(x\) should not be a free variable in \(e\). This is a reasonable assumption though. The semantics of the typing derivations defined earlier tells us</p> \[\begin{align*} &amp;[\![\Gamma\vdash \lambda x:A.e\;x:A\to B]\!]\\ =&amp;curry([\![\Gamma,x:A \vdash e\;x:B]\!])\\ =&amp;curry(\epsilon_{A,B}\circ \langle[\![\Gamma,x:A\vdash e:A\to B]\!],[\![\Gamma,x:A\vdash x:A]\!]\rangle)\\ =&amp;curry(\epsilon_{A,B}\circ \langle[\![\Gamma,x:A\vdash e:A\to B]\!],\pi_2\rangle)\\ =&amp;curry(\epsilon_{A,B}\circ \langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle) \end{align*}\] <p>Tho a mouthful, \(\epsilon_{A,B}\circ\langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle\) is a morphism from \([\![\Gamma]\!]\times [\![A]\!]\) to \([\![B]\!]\). If we set \(C\) to be \([\![\Gamma]\!]\), and \(f\) as \(\epsilon_{A,B}\circ\langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle\), then the diagram for the unit equation becomes</p> <div align="center"> <iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsMyxbMCwwLCJbXFwhW1xcR2FtbWFdXFwhXVxcdGltZXMgW1xcIVtBXVxcIV0iXSxbMCwyLCJbXFwhW0JdXFwhXV57W1xcIVtBXVxcIV19XFx0aW1lcyBbXFwhW0FdXFwhXSJdLFsyLDIsIltcXCFbQl1cXCFdIl0sWzEsMiwiXFxlcHNpbG9uX3tBLEJ9IiwyXSxbMCwxLCJnIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMiwiZiJdXQ==&amp;embed" width="400" height="400" style="border-radius: 8px; border: none;"></iframe> </div> <p>Where did the mystery \(g\) come from? Well, since \(f\) is of the form \(\epsilon_{A,B}\) composed with <em>something</em>, we can just define \(g\) to be the <em>something</em>, aka \(\langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle\), and the above diagram will trivially commute. But, note \(g\) is actually equal to \([\![\Gamma\vdash e:A\to B]\!]\times \text{id}_{[\![A]\!]}\).</p> <p>Finally, for the real kicker, we invoke the uniqueness of \(curry\) in the universal property of \(\epsilon_A\), so that \([\![\Gamma\vdash e:A\to B]\!]=curry(\epsilon_{A,B}\circ \langle[\![\Gamma\vdash e:A\to B]\!]\circ\pi_1,\pi_2\rangle)\). This concludes the proof that our categorical semantics respects eta-equivalence:</p> \[[\![\Gamma\vdash \lambda x:A.e\;x:A\to B]\!]=[\![\Gamma\vdash e:A\to B]\!]\] <h1 id="conclusion">Conclusion</h1> <p>This was mostly just an exercise for me to make sure that the categorical semantics of STLC is sensible. Indeed, we have verified parts of the analogy from the nlab “computational trilogy” table, that the semantic respects \(\beta\) and \(\eta\) equivalence. Actually, the proof came down exactly to the unit \(\eqref{eq:unit}\) and counit \(\eqref{eq:counit}\) equations, just as in the table.</p> <p>Note that our version of STLC doesn’t contain any “ground types” besides \(\texttt{Unit}\). One can simply add more ground types like \(\texttt{Int}, \texttt{Bool}, \texttt{Number}\), etc. The translation will then be incorporated to map each ground type to some designated object in our CCC, and the proof still works because it was defined inductively on the typing derivations. However, in this way the categorical semantics will not be able to enforce fine-grained equational constraints like <code class="language-plaintext highlighter-rouge">40+2=42</code> on the operational semantics.</p>]]></content><author><name></name></author><category term="category"/><category term="pl"/><summary type="html"><![CDATA[Blank]]></summary></entry></feed>